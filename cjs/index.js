var w=Object.create;var v=Object.defineProperty;var E=Object.getOwnPropertyDescriptor;var M=Object.getOwnPropertyNames;var A=Object.getPrototypeOf,G=Object.prototype.hasOwnProperty;var L=(e,t)=>{for(var s in t)v(e,s,{get:t[s],enumerable:!0})},O=(e,t,s,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of M(t))!G.call(e,r)&&r!==s&&v(e,r,{get:()=>t[r],enumerable:!(n=E(t,r))||n.enumerable});return e};var b=(e,t,s)=>(s=e!=null?w(A(e)):{},O(t||!e||!e.__esModule?v(s,"default",{value:e,enumerable:!0}):s,e)),x=e=>O(v({},"__esModule",{value:!0}),e);var H={};L(H,{gopool:()=>o});module.exports=x(H);var a=[],c={};var P=b(require("events"));var y=({app:e,pool:t,timeout:s,headerGetter:n})=>{a.forEach(r=>{r.method==="GET"?e.get(r.url,async({query:u,headers:l})=>{let i=new P.default,d=setTimeout(()=>{i.emit("abort")},s),f=await t.run({uri:r.method+r.url,body:u,headers:n(l)},{signal:i});return clearTimeout(d),f}):e[r.method.toLocaleLowerCase()](r.url,async({body:u,headers:l})=>{let i=new P.default,d=setTimeout(()=>{i.emit("abort")},s),f=await t.run({uri:r.method+r.url,body:JSON.parse(u),headers:n(l)},{signal:i});return clearTimeout(d),f})})};var T=async(e,t,{timeout:s=1e4,minThreads:n=0,maxThreads:r,maxQueue:u,idleTimeout:l=5e3}={})=>{if(await new Promise(m=>setTimeout(m,200)),!t.onMaster)return;let i=require("node:cluster");if(i.isPrimary){i.fork(),i.on("exit",(m,p,S)=>{console.log(`worker ${m.process.pid} died`),i.fork()});return}let d=require("fastify"),g=require("node:os").cpus().length-1;g<2&&(g=2),r||(r=g),u||(u=g*2500);let h=d();if(e==="threadsPool"){let m=require("piscina");try{let p=new m({filename:__filename,env:process.env,execArgv:process.execArgv,argv:process.argv,idleTimeout:l,minThreads:n,maxThreads:r,maxQueue:u});await async function(){let S=t.headerGetter;y({app:h,pool:p,timeout:s,headerGetter:S})}(),await Promise.resolve(t.onMaster({app:h,pool:p}))}catch(p){console.error(p),h.log.error(p)}}else await async function(){let m=t.headerGetter;y({app:h,pool:null,timeout:s,headerGetter:m})}(),await Promise.resolve(t.onMaster({app:h,pool:null}))};var o=async({uri:e,body:t,headers:s})=>{o.onMaster=null;let n=c[e];return n?await Promise.resolve(n({body:t,headers:s})):Error("Not found uri: "+e)};o.all=(e,t)=>{a.push({url:e,method:"ALL"}),c["ALL"+e]=t};o.get=(e,t)=>{a.push({url:e,method:"GET"}),c["GET"+e]=t};o.post=(e,t)=>{a.push({url:e,method:"POST"}),c["POST"+e]=t};o.put=(e,t)=>{a.push({url:e,method:"PUT"}),c["PUT"+e]=t};o.patch=(e,t)=>{a.push({url:e,method:"PATCH"}),c["PATCH"+e]=t};o.delete=(e,t)=>{a.push({url:e,method:"DELETE"}),c["DELETE"+e]=t};o.options=(e,t)=>{a.push({url:e,method:"OPTIONS"}),c["OPTIONS"+e]=t};o.headerGetter=e=>({});o.onMaster=void 0;o.startWithSingle=()=>T("single",o);o.startWithThreadsPool=e=>T("threadsPool",o,e);0&&(module.exports={gopool});
