var E=Object.create;var v=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var M=Object.getOwnPropertyNames;var A=Object.getPrototypeOf,G=Object.prototype.hasOwnProperty;var L=(e,t)=>{for(var s in t)v(e,s,{get:t[s],enumerable:!0})},O=(e,t,s,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of M(t))!G.call(e,r)&&r!==s&&v(e,r,{get:()=>t[r],enumerable:!(n=w(t,r))||n.enumerable});return e};var b=(e,t,s)=>(s=e!=null?E(A(e)):{},O(t||!e||!e.__esModule?v(s,"default",{value:e,enumerable:!0}):s,e)),x=e=>O(v({},"__esModule",{value:!0}),e);var H={};L(H,{yellowDuck:()=>o});module.exports=x(H);var a=[],c={};var P=b(require("events"));var T=({app:e,pool:t,timeout:s,headerGetter:n})=>{a.forEach(r=>{r.method==="GET"?e.get(r.url,async({query:p,headers:d})=>{let i=new P.default,h=setTimeout(()=>{i.emit("abort")},s),f=await t.run({uri:r.method+r.url,body:p,headers:n(d)},{signal:i});return clearTimeout(h),f}):e[r.method.toLocaleLowerCase()](r.url,async({body:p,headers:d})=>{let i=new P.default,h=setTimeout(()=>{i.emit("abort")},s),f=await t.run({uri:r.method+r.url,body:JSON.parse(p),headers:n(d)},{signal:i});return clearTimeout(h),f})})};var y=async(e,t,{timeout:s=1e4,minThreads:n=0,maxThreads:r,maxQueue:p,idleTimeout:d=5e3}={})=>{if(await new Promise(m=>setTimeout(m,200)),!t.onMaster)return;let i=require("node:cluster");if(i.isPrimary){i.fork(),i.on("exit",(m,u,S)=>{console.log(`worker ${m.process.pid} died`),i.fork()});return}let h=require("fastify"),g=require("node:os").cpus().length-1;g<2&&(g=2),r||(r=g),p||(p=g*2500);let l=h();if(e==="threadsPool"){let m=require("piscina");try{let u=new m({filename:__filename,env:process.env,execArgv:process.execArgv,argv:process.argv,idleTimeout:d,minThreads:n,maxThreads:r,maxQueue:p});await async function(){let S=t.headerGetter;T({app:l,pool:u,timeout:s,headerGetter:S})}(),await Promise.resolve(t.onMaster({app:l,pool:u}))}catch(u){console.error(u),l.log.error(u)}}else await async function(){let m=t.headerGetter;T({app:l,pool:null,timeout:s,headerGetter:m})}(),await Promise.resolve(t.onMaster({app:l,pool:null}))};var o=async({uri:e,body:t,headers:s})=>{o.onMaster=null;let n=c[e];return n?await Promise.resolve(n({body:t,headers:s})):Error("Not found uri: "+e)};o.all=(e,t)=>{a.push({url:e,method:"ALL"}),c["ALL"+e]=t};o.get=(e,t)=>{a.push({url:e,method:"GET"}),c["GET"+e]=t};o.post=(e,t)=>{a.push({url:e,method:"POST"}),c["POST"+e]=t};o.put=(e,t)=>{a.push({url:e,method:"PUT"}),c["PUT"+e]=t};o.patch=(e,t)=>{a.push({url:e,method:"PATCH"}),c["PATCH"+e]=t};o.delete=(e,t)=>{a.push({url:e,method:"DELETE"}),c["DELETE"+e]=t};o.options=(e,t)=>{a.push({url:e,method:"OPTIONS"}),c["OPTIONS"+e]=t};o.headerGetter=e=>({});o.onMaster=void 0;o.startWithSingle=()=>y("single",o);o.startWithThreadsPool=e=>y("threadsPool",o,e);0&&(module.exports={yellowDuck});
